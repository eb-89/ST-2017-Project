\documentclass[10pt]{article}

\usepackage{listings}
\usepackage{courier}
\usepackage{color}
\usepackage{hyperref}
\usepackage{changepage}



\newcommand{\tbt}[1]{\texttt{\textbf{#1}}}

\definecolor{orange}{rgb}{1,0.6,0.2}
\definecolor{light-blue}{rgb}{0,0.6,1}
\definecolor{dark-green}{rgb}{0.05,0.4,0}

\lstdefinestyle{htmlstyle}{
  language = html,
  basicstyle=\small\ttfamily,
  tagstyle=\color{blue}
}


\lstdefinestyle{pythonstyle-small}{
  language = python,
  basicstyle=\bf\footnotesize\ttfamily,
  keywordstyle=\color{blue},
  identifierstyle=\color{black},
  stringstyle=\color{dark-green},
  commentstyle=\color{light-blue},
  morekeywords = {[2]@classmethod},  %%Add decorators here, there is only one in the code so far.
  keywordstyle={[2]\color{red}},
  morestring=[s]{'''}{'''},
  showstringspaces=false,
  numbers=left,
  stepnumber=1
}

\lstdefinestyle{pythonstyle-with-numbers}{
  language = python,
  basicstyle=\bf\small\ttfamily,
  keywordstyle=\color{blue},
  identifierstyle=\color{black},
  stringstyle=\color{dark-green},
  commentstyle=\color{light-blue},
  morekeywords = {[2]@classmethod},  %%Add decorators here, there is only one in the code so far.
  keywordstyle={[2]\color{red}},
  morestring=[s]{'''}{'''},
  showstringspaces=false,
  numbers=left,
  stepnumber=1
}

\lstdefinestyle{pythonstyle}{
  language = python,
  basicstyle=\bf\small\ttfamily,
  keywordstyle=\color{blue},
  identifierstyle=\color{black},
  stringstyle=\color{dark-green},
  commentstyle=\color{light-blue},
  morekeywords = {[2]@classmethod},  %%Add decorators here, there is only one in the code so far.
  keywordstyle={[2]\color{red}},
  morestring=[s]{'''}{'''},
  showstringspaces=false
}



\title{Testing BeautifulSoup \\ \small A software testing project \\ Uppsala University 2017}

\author{Erik Bertse \\ Sara Gustavsson \\ Moa Marklund \\ Henrik Thorsell}
\date{}

\begin{document}

\maketitle

\begin{abstract}
  The BeautifulSoup library is a Python library designed to easily search and manipulate data associated with HTML/XML markup. In this project, we test the functionality of this library. Most of the available API functions have been subject to black-box testing. One of the functions was selected to undergo white-box testing. Our testing has resulted in the discovery on some irregularities.
\end{abstract}

\section{Introduction}

\subsection{What is BeautifulSoup?}
 BeatifulSoup is a library for Python which provides functionality for navigating and extracting data from HTML and XML markup. It does so by using external parsers, specifiable by the users of the library, whose output is assembled by BeautifulSoup to generate a tree structure, the nodes of which are tags in the HTML/XML markup. Thus, children of any given tag are nested tags. \\

 The BeautifulSoup library is compatible with Python 2.7 and Python 3.2, but we have limited the scope of our testing to using version 2.7. The most recent version of BeautifulSoup is 4, abbreviated BS4. Previous (and no longer supported) versions of BeautifulSoup are available, but are not subject to any tests in this project.  \\

Given some markup, the library creates a \textit{Soup} object, containing all the information in the markup. In the following example, we call the BeautifulSoup constructor with some markup, using the HTML parser that comes with Python: 
\newpage

\begin{lstlisting}[style = pythonstyle]
a_simple_soup = BeautifulSoup(
    '''
    <html>
      <head>
      </head>
      <body>
        <p>
          <a>An anchor tag</a>
        </p>
      </body>
    </html>
    ''', "html.parser")
\end{lstlisting}

The soup object created is a rather complex. Each tag in the markup gives rise to an object inside the soup, simply referred to as a \textit{Tag} object. The text inside a tag gives rise to a \textit{NavigableString} object, which, for our purposes, works like a Python string. Tags are then organized in a tree structure, such that any inner tag is a child of its parent tag. The soup class itself inherits from the tag class, and therefore all soup objects are also tag objects. 

The following example show how to use class attributes to access tag objects in the tree structure. To access the tag object which corresponds to the head tag, and assign it to a variable, we would write the following code:

\begin{lstlisting}[style = pythonstyle]
tag = a_simple_soup.head
\end{lstlisting}

Note that we are not required to first access its parent, i.e. we do not have to specify
\begin{lstlisting}[style = pythonstyle]
a_simple_soup.html.head
\end{lstlisting}
although this is perfectly valid also. If the tree structure contains several tags with the same name, then the first one in the markup will be accessed. Please refer to the `Discussion' section for more information on how this works. \\

The library contains a number of functions for navigating and modifying the tree, many of which were tested in this project. The following call exemplifies searching the tree. The call: 

\begin{lstlisting}[style = pythonstyle]
lst = a_simple_soup.find_all("a")
\end{lstlisting}
will return a list of all tag objects, whose name is \texttt{\textbf{a}}, in the tree structure. \\

We can also modify the tree in various ways. The following call clears the contents of the \texttt{\textbf{html}} tag:

\begin{lstlisting}[style = pythonstyle]
a_simple_soup.html.clear()
\end{lstlisting}

Many other functions are available. We refer the curious reader to the BeautifulSoup documentation, for a complete list. The documentation is available here: \url{https://www.crummy.com/software/BeautifulSoup/bs4/doc/}


\section{Method}

We have tested a subset of the total functionality of the BeautifulSoup library. The testing was organized in two stages, black box testing and white box testing. 


\subsection{Black box testing}

We started by looking over the total functionality of the BeautifulSoup library. This included reading all the documentation, and quickly going over the source code. We finally decided to perform black box testing on the following functionality, divided into three sections.

\begin{itemize}
  \item Navigation with class attributes. \\
  The following attributes were selected: 
  \begin{itemize}
   \setlength\itemsep{-0.05em}
   \item \tbt{contents}
   \item \tbt{children}
   \item \tbt{descendants} 
   \item \tbt{string}
   \item \tbt{strings}
   \item \tbt{stripped\_strings}
   \item \tbt{parent}
   \item \tbt{parents}
  \end{itemize} 
  There are also tests provided for two of the following ``attributes''
  \begin{itemize}
  \setlength\itemsep{-0.05em}
   \item \tbt{soup.head}
   \item \tbt{soup.title} 
  \end{itemize}
  There were originally plans to provide more tests of the last mentioned kind, but these were cut. Please refer the the discussion section for more information on this.

  \item Searching the tree. \\
  The following search functions were selected: 
  \begin{itemize}
  \setlength\itemsep{-0.05em}
    \item \tbt{find()}
    \item \tbt{find\_all()}
    \item \tbt{find\_parents()}
    \item \tbt{find\_parent()}
    \item \tbt{find\_all\_next()}
    \item \tbt{find\_next()}
    \item \tbt{find\_all\_previous()}
    \item \tbt{find\_previous()}
    \item \tbt{select()}
  \end{itemize}

  \item Modifying the tree. \\
  The following modifying functions were selected:
    \begin{itemize}
    \setlength\itemsep{-0.05em}
      \item \tbt{append()}
      \item \tbt{insert\_before()}
      \item \tbt{insert\_after()}
      \item \tbt{clear()}
      \item \tbt{extract()}
      \item \tbt{decompose()}
      \item \tbt{replace\_with()}
      \item \tbt{wrap()}
      \item \tbt{unwrap()}
    \end{itemize}
\end{itemize}

%Instructions\\
%%You should describe all your tests, both black and white box tests. For your tests you should describe how you derived them and what the tests do. Obviously you will describe some tests in groups. If you have over 100 tests in your code, then we do not expect 100 separate descriptions.

Since all the functions and attributes listed above require soup objects or tag objects to operate on, we proceeded to define test data. This was done in the initialization code in the file containing the black box tests. Here we initialized several soup objects, by feeding some markup into the soup constructor. The markup was selected to be small and easy to read, yet provided enough structure to write non-trivial tests.  \\ 

Many, but not all, of the tests that pertain to navigation and searching use this test data. \\

Unfortunately, all of the functions that modify the tree could not be run on this test data. If a test modifies the tree structure in some way, then the next test would obviously use the modified test data, which was not our intention.

The solution was to define a new soup object for each test that modifies the tree structure. The markup used is generally very short, only as much as necessary to test the modification under consideration. \\

The expected output of navigation and searching is almost always a tag object. Given a soup object to be tested, we define free-standing tag using the \tbt{new\_tag()} function. We use these tags to compare with the output of the function under consideration. See the Discussion section for details on Tag and Soup equality. \\

We used the documentation as a specification on what each function should return. We let the specification inform the tests. Where applicable, there are tests to test negative results (e.g. searching for a tag that is not present), or edge cases (e.g. clearing the contents of an empty tag). \\

There are 53 tests in total. The purpose of each test in specified as a docstring.


\subsection{White box testing}

The following functions were selected for white box testing:

\begin{itemize}
  \setlength\itemsep{-0.05em}
  \item \tbt{find()} \qquad Public function
  \item \tbt{find\_all()} \qquad Public function
  \item \tbt{\_find\_all()} \qquad Private function
\end{itemize}

The goal of the white box testing was to attain full branch coverage of these functions. Since \texttt{\textbf{find()}} and \texttt{\textbf{find\_all()}} are mostly wrappers for the private function \texttt{\textbf{\_find\_all()}}, attaining full branch coverage of these functions was easy. Covering each branch in \texttt{\textbf{\_find\_all()}} proved much more challenging. \\

We started by studying the internal structure of the function. This allowed us to write calls to the \tbt{\_find()} and \tbt{\_find\_all()} functions, in such a way, that each call allowed for different statements to be executed. This let us achieve full statement coverage. \\

Unfortunately, this code was not sufficient to achieve branch coverage, and we had to extend it.

To achieve full branch coverage, we had to step far outside the normal usage the BeautifulSoup library, and break a few Python principles along the way. See the Discussion section for how this was done.

\section{Results}

\subsection{Black box testing}

The following tests do not pass:

\begin{lstlisting}[style = pythonstyle]
test_css_select_empty(self):
  ''' Test the select function with an empty string '''

test_replace_tag_with_string(self):
  ''' Test replacing tag with string '''

test_unwrap(self):
  ''' Test unwrapping and compare to soup after unwrapping.'''

test_find_empty(self):
  ''' Test finding a tag with no name '''
\end{lstlisting}

The first test does not pass because the an inner function throws an IndexError. \\
It is debatable whether the second, third and fourth test should be considered bugs, or whether this is normal functionality of BeautifulSoup. See Discussion section.

\subsection{White box testing}

We successfully achieved full branch coverage of the \tbt{find()}, \tbt{find\_all()} and \tbt{\_find\_all()} function, but only through bizarre usage of both BeautifulSoup and Python. 

Coverage was measured with the tool called Coverage \footnote{\url{https://coverage.readthedocs.io/en/coverage-4.4.2/}}

\section{Discussion}

\subsection{The documentation}

The documentation available for the library is presented in a relatively informal style, with small and informal examples. There does not seem to be any rigorous documentation available, and therefore, it is not always clear what functions should return (or what modifications will be made to the tree structure) in edge cases. For example, for functions that takes strings as parameters, the library's behavior on an empty string is unclear. We have therefore been forced on make subjective decisions as to what makes a test pass. 

This has resulted in some failing tests, although, in all cases but one, the results are debatable. Please see the failing black box testing subsection further down.

\subsection{Class attributes and navigation}

Originally, the intention was to perform more extensive testing on navigation using the following syntax:
\begin{lstlisting}[style = pythonstyle]
a_simple_soup.html.head
\end{lstlisting}
Tests for finding \tbt{html} and \tbt{title} tags were written, and is still part of the black box testing file. After further study of the how Python attributes work, the following property of Python language was discovered: Given an object, if an attribute is not defined (as a function, for example), calling that attribute will invoke the function 

\tbt{\_\_getattr\_\_()}. \\

If this function is defined as 

\tbt{\_\_getattr\_\_(self, arg)}, 

then the name of the attribute is passed as the \tbt{arg} parameter.

Looking at the BeautifulSoup source code revealed the following function:
\begin{lstlisting}[style=pythonstyle]
  def __getattr__(self, tag):
        ... #Code omitted here
        return self.find(tag)
\end{lstlisting}

Thus, using attributes for navigation is subsumed by tests that use the \tbt{find()} function, and we therefore scrapped plans for testing this further. Please note that this is not true for the first set of attributes (such as \tbt{children} and \tbt{contents}), which are defined as separate functions and are therefore tested.

\subsection{Tag and Soup equality}

For quite some time during the the development of the tests, there were inconsistencies regarding how to compare two tags. Some tests compared tags for equality by comparing their string representations. Although this is not a bad idea, ultimately, it did not capture the nested structure of the tree. \\

The documentation states: 
\begin{center}
  \textit{Beautiful Soup says that two NavigableString or Tag objects are equal when they represent the same HTML or XML markup.} \footnote{Copied verbatim from the documentation}
\end{center}

A more rigorous definition was found inside the BeautifulSoup source:
\begin{lstlisting}[style = pythonstyle]
  def __eq__(self, other):
        '''Returns true iff this tag has the same name, the same attributes,
        and the same contents (recursively) as the given tag.'''
\end{lstlisting}

The Soup class contains a factory function called \tbt{new\_tag()} that generates a new tag. This tag is not placed in the tree structure. Thus, to compare the output of a function, we define a new tag, and compare the expected output with this tag.

The tests underwent consistency rework, so that all tests conformed with this notion of tag equality. It is also on basis of this notion of equality that some tests fail. 

\subsection{The failing black box tests}

Here we provide details for the tests that fail. For convenience, we provide line numbers of where the tests can be found in the black box testing file. \\

\noindent\begin{minipage}{\textwidth}
\indent{\hspace{12pt}} The test at line 349:
\begin{lstlisting}[style = pythonstyle]
test_css_select_empty(self):
  ''' Test the select function with an empty string '''
\end{lstlisting}
\end{minipage}
fails. The function \tbt{select()} is used to find tags based on CSS selectors. For example, calling this function like so:
\begin{lstlisting}[style = pythonstyle]
soup.select("#my_id")
\end{lstlisting}
will return a list of items tags whose \tbt{id} attribute equals \tbt{\color{dark-green} my\_id}.  \\


The documentation does not specify the behavior of this function when the input is an empty string. We made the subjective assumption that the call should return \tbt{None}, but instead, BeautifulSoup crashes with an uncaught IndexError, so we consider this a proper bug. \\

\noindent\begin{minipage}{\textwidth}
\indent{\hspace{12pt}} The tests at lines 612 and 670
\begin{lstlisting}[style = pythonstyle]
test_replace_tag_with_string(self):
  ''' Test replacing tag with string '''
test_unwrap(self):
  ''' Test unwrapping and compare to soup after unwrapping.'''
\end{lstlisting}
\end{minipage}

fail. They both fail for similar reasons. The \tbt{replace()} function should replace given element with another element. The \tbt{unwrap()} function would remove a tag, but leave the tag's contents untouched. 


The issue here is that the tree structure is not updated accordingly. Consider a soup created from the following markup:
\begin{lstlisting}[style = htmlstyle]
  <a href="http://example.com/">I linked to <i>example.com</i></a>
\end{lstlisting}
One would expect that after unwrapping the \tbt{i}-tag, the contents of the \tbt{a}-tag should be a string. This is not the case, instead, the contents of the \tbt{a}-tag is a list containing two strings, one of which is what used to be the contents of the \tbt{i}-tag. If we modify the tree using the \tbt{unwrap()}-function, the value of \tbt{tagstring} after the call
\begin{lstlisting}[style = pythonstyle]
  tagstring = soup.a.string
\end{lstlisting}
is \tbt{None}. 
Again, the functionality at this level of detail is not specified in the documentation, so it is a subjective assessment that this is erroneous behavior. \\

The \tbt{replace()} function does not pass for the same reason, the modification of the tree is not updated properly, when replacing a tag with a string. \\

\noindent\begin{minipage}{\textwidth}
\indent{\hspace{12pt}} The test at line 317
\begin{lstlisting}[style = pythonstyle]
test_find_empty(self):
  ''' Test finding a tag with no name '''
\end{lstlisting}
\end{minipage}
fails. Here we run the \tbt{find()} function with an empty string. Again, the behavior of this call is not specified in the documentation. Our assumption is that the result should be \tbt{None}, especially since it is possible to define a tag with an empty name. This function returns the \tbt{html} tag (whose name is certainly not empty). One could suspect that this call will return the soup object itself, but this is also not true. 

\subsection{The white box hacks}

The goal of the white box testing was to achieve full branch coverage of the functions \tbt{find()}, \tbt{find\_all()}, and the internal function \tbt{\_find\_all()}. It turned out that \tbt{find()} calls the function \tbt{find\_all}, which in turn calls \tbt{\_find\_all()}. This internal function is relatively complicated, and the test file for branch coverage contains various calls so as to execute every branch. We direct the interested reader to the BeautifulSoup source code, available freely on GitHub, and only discuss the more challenging parts here. \\

\noindent\begin{minipage}{\textwidth}
\indent{\hspace{12pt}} A section of \tbt{\_find\_all()} is the following code:
\begin{lstlisting}[style = pythonstyle-with-numbers]
#...Code omitted here
while True:
    try:
        i = next(generator)
    except StopIteration:
        break
    if i:
        found = strainer.search(i)
        if found:
            results.append(found)
            if limit and len(results) >= limit:
                break
  return results
\end{lstlisting}
\end{minipage}

Making line 7 in the above excerpt false required some trickery. Python generators are a type of Python iterator objects which contain a function called \tbt{next} that return themselves, so \tbt{i}, at line 7, is an iterator object. Objects in Python generally return true when evaluated as a boolean (but not always). Even if the iterator was empty, the loop would break at line 6, before ever reaching line 7. So, given normal usage, the line 7 will always return true. \\

The solution was to write a custom iterator class, and override its \tbt{\_\_len\_\_} function, to always return 0, while making sure that it would iterate a number of times first. This way, we can assure that the condition on line 7 evaluates to false a certain number of times before the iterator throws the StopIteration exception. We do this to prevent an infinite loop. Note that this iterator was written specifically to break BeautifulSoup, and not even close to how iterators are supposed to work. The code for this custom iterator can be found in the white box testing file. \\

After this, we feed this custom iterator directly into \tbt{\_find\_all()}, since feeding the iterator into both \tbt{find()} and \tbt{find\_all()} causes BeautifulSoup to throw a TypeError exception. Note that this is not the intended usage of BeautifulSoup, yet the only way we found to execute the false branch at line 7 to execute. \\

Through this method we achieved 100\% branch coverage of these functions. 






\section{Conclusion}

We performed black box testing on a selection of function in the BeautifulSoup library. We found some discrepancies, but most of the functions performed as expected. We also performed white box testing on a selected function, which entailed achieving full branch coverage of this function. Here, we succeeded, although we had to use ad hoc solutions to do this.

\section{Appendix}

The file \tbt{unittest\_tests.py} contains the code for black box testing. \\
the file \tbt{unittest\_cov\_tests.py} contains the code for black box testing. \\
\vspace{1em}

\begin{adjustwidth}{-6.5em}{0em}
The file \tbt{unittest\_tests.py}:
\lstinputlisting[style = pythonstyle-small]{unittest_tests.py} 
\vspace{1em}

The file \tbt{unittest\_cov\_tests.py}
\lstinputlisting[style = pythonstyle-small]{unittest_cov_tests.py}
\end{adjustwidth}

\end{document}
